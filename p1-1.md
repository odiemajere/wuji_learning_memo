# 1-1.2 单片机的资源有哪些

以 STC15W104 为例

1. 工作电压
   - 2.4v-5.5v
2. 程序空间
   - 4K
   - 又叫 FLASH 或 ROM
   - 用来存储单片机的代码程序
   - 以 4K 为例，4K=4096bytes，代表可存储的代码总量为不超过 4096 字节
   - 编译结果中 code 后的数字为代码字节数
3. SRAM
   -128bytes -用来存储单片机代码中的变量 -此处变量的定义不能超过 128 字节
4. EEPROM
   - 1K
   - 具有掉电保存功能
5. I/O
   - 6 个
   - 输入输出端口，外部资源
   - STC15W104 为 8 脚芯片，除了 VCC 和 GND 其余均为 I/O
6. 定时器
   - 两个
   - 具有精准定时功能
7. 串口
   - 无
   - 串口为单片机和外部设备之间建立通讯的标准接口
   - `单片机-电脑` `单片机-单片机` `单片机-wifi` `单片机-4G模块`等
8. ADC
   - 无
   - 高端的单片机一般会集成的功能
   - 把模拟的电压转换成数字
   - 带有 ADC 功能的 I/O 口可以识别一个模拟量的电压
9. DAC
   - 无
   - 输出模拟的电压值（0-VCC）
   - 普通的 I/O 只能输出高低电平
10. SPI/IIC
    - 无
    - 都是标准通讯接口
    - 一般用来芯片间通讯
11. 看门狗
    - 无
    - 用来防止代码程序死机或非正常运行

## 1-1.3 `二进制` `十进制` `十六进制`

| 十进制 | 二进制 | 十六进制 |
| :----: | :----: | :------: |
|  Dec   |  Bin   |   Hex    |
|   0    |  0000  |    00    |
|   1    |  0001  |    01    |
|   2    |  0010  |    02    |
|   3    |  0011  |    03    |
|   4    |  0100  |    04    |
|   5    |  0101  |    05    |
|   6    |  0110  |    06    |
|   7    |  0111  |    07    |
|   8    |  1000  |    08    |
|   9    |  1001  |    09    |
|   10   |  1010  |    0A    |
|   11   |  1011  |    0B    |
|   12   |  1100  |    0C    |
|   13   |  1101  |    0D    |
|   14   |  1110  |    0E    |
|   15   |  1111  |    0F    |
|   16   | 10000  |    10    |

1. 进制转换的原因：
   - 存储器是计算机系统中的记忆设备，用来存放程序和数据
   - 构成存储器的存储介质，目前主要采用半导体器件和磁性材料
   - 存储器中最小的存储单位就是一个双稳态半导体电路或一个 CMOS 晶体管或磁性材料的存储元，它可存储一个二进制代码(0 或 1)
   - 8 个存储元组成一个 Byte(字节)，然后再由许多字节组成一个存储器
2. 不同数据之间一般以 10 进制为桥梁进行转换
3. 任意进制转十进制：给每一位数字乘以位数的进制次方然后相加
4. 使用场景
   - 二进制：单个 I/O 口的配置。使用较少，一般转为 16 进制使用
   - 十进制：算术运算，逻辑运算
   - 十六进制：寄存器的配置。与，或运算
5. 表示方法
   - 二进制 b0010 0011
   - 十进制 35
   - 十六进制 0x23

## 1-1.4 C51 点亮第一个 led 灯

### 任务：

- 点亮无线门磁探测器模块的 LED1 和 LED2

### 准备：

- 无线门磁模块（STC15W104）
- 烧录器（ST-link）
- 数字电源
- PC 主机（安装 KEIL C51）

### 流程：

    1. 安装KEIL C51并破解
    2. 安装USB-串口驱动程序（本课使用ch340）
    3. 使用STC-ISP软件将STC系列芯片的头文件添加到KEIL库中
    4. 运行KEIL，
        - 新建project，命名为LED
        - 新建main.c文件到工程LED的文件夹内
        - 右键点击Source Group 选择add existing file to ‘Source Group 1’将main.c文件添加到工程里
        - 现在开始编辑main.c文件
            * 输入

            void main(void)
            {
                    systeminit();
                    while(1)
                {  ...
                }
            }

            * 右键添加头文件 #include <STC15.H>
            * 本节所用芯片为STC15W04，没有严格对应的头文件。本芯片为STC15系列芯片，可以用通用头文件STC15.H
            * 在options for target内选择生成.hex文件并对所生成的文件命名
            * 点击build
        - 在objects文件夹内找到相应的.hex文件
    5. 运行STC-ISP程序
        - 选择芯片型号STC15W104
        - 选择串口（上述第2步中的串口端口）
        - 选择 输入用户程序运行时的IRC频率为5.5296MHz（本次模块的运行频率）
        - 点击 打开程序文件，选择第4步生成的.hex文件
    6. 用USB-串口线连接电脑与单片机对应端口GND-GND TXD-RXD RXD-TXD 5V-VCC
    7. 在STC-ISP内点击“下载/编程”->用数字电源给单片机供电（此处给出6v供电，这叫做冷启动烧录，指烧录程序的时候先断电，启动软件进入烧录状态，然后再给设备供电）
    8. 看一下无线门磁探测器模块的原理图，发现led1与p3.1相连，led2与p3.0相连。
    9. 在KEIL内编辑main.c
        * 首先在void main(void){}外面定义两个端口
        * sbit LED1 = P3^1;
        * sbit LED2 = P3^0;
        * 然后在void main(void){}内部给LED1和LED2赋值，0为灭灯，1为点亮灯

### 小结：

- C 语言源程序->C 编译器->汇编代码->汇编器->机器代码(.hex .bin)
- 单片机可以识别的文件类型为.hex 或.bin

- 而在 C 语言程序中 main 函数，又是程序执行的起点，是所有程序运行的入口

```C
#include <STC15.H>
sbit LED1 = P3^1;
sbit LED2 = P3^0;

//高低电平
//低电平		GND		0V
//高电平		VCC		单片机的VCC 供电电压
//单片机的普通IO只能输出高电平或低电平
//IO = 0		输出低电平		0V
//IO = 1		输出高电平		VCC

void main(void)
{
	LED1 = 1;//0为低电平，灭灯。1为高电平，亮灯
	LED2 = 1;
	while(1);
}
```

## 1-1.5 C 语言中的变量

### C 语言的数据类型

1. 基本类型
   - 整数型
     - int-有符号整形-16 位(-32768~32767)
     - unsigned int-无符号整形-16 位(0~65535)
     - short
     - long-有符号长整形-32 位(-2^31~2^31-1)
     - unsigned long-无符号长整形-32 位(0~2^32-1)
   - 浮点型
     - float-单精度实数-32 位(3.4e-38~3.4e38)
     - double-双精度实数-64 位(1.7e-308~1.7e308)
   - 字符型
     - char-有符号字符型-8 位(-128~127)
     - unsigned char-无符号字符型-8 位(0~255)
   - 布尔型
     - bit-位类型-1 位(0~1)
   - 枚举型
     - enum
2. 构造类型
   - 数组
     - DataType[long]
   - 结构体
     - struct
   - 联合体
     - union
3. 空类型

### 变量定义的规则

1. 变量是由英文字母（大小写）、数字、下划线组成
2. 变量名以英文字母开头(或下划线)
3. 变量名中的字母是区分大小写的；
4. 变量名不能是关键字
   - C 语言中的关键字举例：auto、break、case、char、const、continue、default、do、double、else、enum、extern、float、for、goto、if、int、long、register 等
   - KEIL 中关键字一般是蓝色字体
5. 变量名中不能包含空格、标点符号和类型说明符（可包含下划线）

### 全局变量与局部变量

1. 尽量不要同名
2. 全局变量可以任意调用，局部变量仅在定义的函数内调用

### 范例

```C
//如何表示今天是星期几？
unsigned char week;//0~255
unsigned int year;//0~65535

//如何表示我的身高
float body_height;//3.4e-38~3.4e38
```

## 1-1.6 C 语言的算数运算符

### C 语言的 10 类运算符

    1. 算术运算符
        - + 加法运算符
        - - 减法运算符
        - * 乘法运算符
        - / 除法运算符
        - % 求余运算符
        - ++ 自增运算符
        - -- 自减运算符
        - 算术运算符的运算结果符合数学逻辑
    2. 关系运算符
    3. 逻辑运算符
    4. 位操作运算符
    5. 赋值运算符
    6. 条件运算符
    7. 逗号运算符
    8. 指针运算符
    9. 求字节数运算符
    10. 特殊运算符

### 练习代码

```C
#include <STC15.H>	//STC15W104
sbit LED1 = P3^1;
sbit LED2 = P3^0;

void delay1sec(void){//delay1sec函数的内容从STC-ISP软件中软件延时计算器中自动生成
unsigned char i, j, k;

//	_nop_();
//	_nop_();
	i = 22;
	j = 3;
	k = 227;
	do
	{
		do
		{
			while (--k);
		} while (--j);
	} while (--i);
}

void main(void){
	unsigned char a,b,c;
	unsigned char i;
	a = 5;
	b = 2;

	c = a + b;//加运算
	c = a - b;//减运算

	c = a * b;//乘运算
	c = a / b;//除运算
	c = a % b;//求余运算

	a ++;//自增运算
	a --;//自减运算
	LED1=0;
	LED2=0;
	for(i=0;i<3;i++){
		LED1=1;
		LED2=1;
		delay1sec();
		LED1=0;
		LED2=0;
		delay1sec();
	}

	while(1);
}
```

## 1-1.7 C 语言关系运算符

### C 语言的 10 类运算符

    1. 算术运算符
    2. 关系运算符
        - <     小于
        - <=    小于等于
        - >     大于
        - >=    大于等于
        - ==    等于
        - !=    不等于
        - 关系运算符的运算结果为真（1）或假（0）
        - 关系运算符一般与if、while语句配合使用
    3. 逻辑运算符
    4. 位操作运算符
    5. 赋值运算符
    6. 条件运算符
    7. 逗号运算符
    8. 指针运算符
    9.  求字节数运算符
    10. 特殊运算符

## 1-1.8 C 语言位运算符

### C 语言的 10 类运算符

    1. 算术运算符
    2. 关系运算符
    3. 逻辑运算符
    4. 位操作运算符
        - & 按位与
        - | 按位或
        - ^ 按位异或
        - ~ 取反
        - << 左移
        - >> 右移
    5. 赋值运算符
    6. 条件运算符
    7. 逗号运算符
    8. 指针运算符
    9.  求字节数运算符
    10. 特殊运算符

| 运算符 | 表达式   | 范例                                                                                 |
| :----: | :------- | :----------------------------------------------------------------------------------- |
|   &    | x&y      | x=1,y=1,x&y=1<br>x=1,y=0,x&y=0<br>x=0,y=1,x&y=0<br>x=0,y=0,x&y=0                     |
| &#124; | x&#124;y | x=1,y=1,x&#124;y=1<br>x=1,y=0,x&#124;y=1<br>x=0,y=1,x&#124;y=1<br>x=0,y=0,x&#124;y=0 |
|   ^    | x^y      | x=1,y=1,x^y=0<br>x=1,y=0,x^y=1<br>x=0,y=1,x^y=1<br>x=0,y=0,x^y=0                     |
|   ~    | ~x       | x=1,~x=0<br>x=0,~x=1                                                                 |

| 表达式    | 位模式 |
| :-------- | :----- |
| int a=6;  | 00110  |
| int b=11; | 01011  |
| a&b       | 00010  |
| a&#124;b  | 01111  |
| a^b       | 01101  |
| ~a        | 11001  |

| 运算符 | 范例  | 结果                                                                                                          |
| :----: | :---- | :------------------------------------------------------------------------------------------------------------ |
|   <<   | a<<b  | a 的每个位向左移 b 个位，<font color="red">被移出的最左位删除</font><br>若无溢出，左移在数学上的意义是 a\*2^b |
|   <<   | a<<=4 | a=a<<4                                                                                                        |
|   >>   | a>>b  | a 的每个位向右移 b 个位，<font color="red">被移出的最右位删除</font><br>右移在数学上的意义是 a/2^b            |
|   >>   | a>>=3 | a=a>>4                                                                                                        |

### 范例代码

```c
if(表达式){
    执行语句
}
```

表达式非 0 即为真，即执行<font color="red">执行语句</font>

## 1-1.9 if 语句

### 格式 1

```c
if (条件表达式){
    语句1；
}
//条件表达式成立，执行语句1。条件表达式不成立，不执行语句1
```

### 格式 2

```c
if (条件表达式){
    语句1；
}
else{
    语句2
}
//条件表达式成立，执行语句1。条件表达式不成立，执行语句2
```

### 格式 3

```c
if (条件表达式1){
    语句1；
}
else if(条件表达式2){
    语句2
}
else{
    语句3
}
//条件表达式1成立，执行语句1。条件表达式1不成立但条件表达式2成立，执行语句2。条件表达式1和条件表达式2都不成立，执行语句3
```

## 1-1.10 while 语句

### 格式 1

```C
while(表达式1){
    语句1
}
//表达式1如果为真，执行语句1
```

### 格式 2

```C
while(1);
//循环等待
```

### 格式 3

```C
do{
    语句2
}
while(表达式2);
//先执行语句2，再判断表达式2是否为真。如果成立继续执行语句2，如果不成立，跳出while语句执行下面的语句
```

### 范例代码段

```C
#include <STC15.H>

sbit LED1 = P3^1;
sbit LED2 = P3^0;
sbit OPEN = P3^5;

unsigned char DoorSta;

// 1. LED1 每隔1秒闪烁一次
// 外部中断 程序  实现的功能是      >>实现门磁开门检测
void Delay100us()		//@5.5296MHz
{
	unsigned char i, j;
	i = 1;
	j = 134;
	do
	{
		while (--j);
	} while (--i);
}


void Delay1000ms()		//@5.5296MHz   演示1秒的延时函数
{
	unsigned char i, j, k;
	i = 22;
	j = 3;
	k = 227;
	do
	{
		do
		{
			while (--k);
		} while (--j);
	} while (--i);
}


void Delay_3s(void)
{
	unsigned char i;
	for(i=0;i<3;i++)
	{
		Delay1000ms();
	}
}


void main(void)
{
	P0M0 = 0x00;
	P0M1 = 0x00;
	P1M0 = 0x00;
	P1M1 = 0x00;
	P2M0 = 0x00;
	P2M1 = 0x00;
	P3M0 = 0x00;
	P3M1 = 0x00;
	P4M0 = 0x00;
	P4M1 = 0x00;

	INT_CLKO |= 0x20;               //(EX3 = 1)使能INT3中断
	EA = 1;
	DoorSta = 0;

	LED1 = 0;
	LED2 = 0;

	while(1)
	{
			if(DoorSta == 1)
			{///有开门操作
					if(OPEN == 0)
					{
							LED1 = 1;
							LED2 = 1;
//							Delay1000ms();
							while(OPEN == 0);
//这里是一个if和while的组合。if的条件符合后，进入{}点亮LED1和LED2。while的条件符合时在这里等待，直到while不符合，才执行wile下面的语句
							LED1 = 0;
							LED2 = 0;
					}

					DoorSta = 0;
			}
//			while(1);一个main函数中不能有两个while(1);否则会死机
	}
}

//中断服务程序
void exint3() interrupt 11          //INT3中断入口
{
   /// P10 = !P10;                     //将测试口取反
		DoorSta = 1;
}

```

<font color="red">本块为染色字体示范</font>

## 1-1.11 do while 语句

### 格式

```C
do{
    语句1
}
while(表达式1)
//先执行语句1，再判断表达式1是否成立。成立，继续执行语句1，不成立跳出while语句执行下面的语句
```

## 1-1.12 switch 语句

### 格式

```C
switch(变量表达式){
    case 常量1:{
        语句1
    }
    break;
    case 常量2:{
        语句2
    }
    break;
    case 常量3:{
        语句3
    }
    break;
    case 常量4:{
        语句4
    }
    break;
    default:{
        语句5//变量不等于以上列出的常量
    }
}
//以快递分拣为例
//switch(包裹){
//      case beijing:
//              beijing box;
//      break;
//      case nanjing:
//              nanjing box;
//      break;
//}

```

## 1-1.13 for 语句

### 格式

```C
for(表达式1;表达式2;表达式3){
    中间循环体;
}
//表达式1：单次表达式，只运行一次
//表达式2：条件表达式，如果条件表达式为真则执行中间循环体
//表达式3：末尾循环体，如果条件表达式为执行完中间循环体语句后执行本语句
//
```

### 范例

```C
void delay_1s(void){
    unsigned char i;
    for(i=0;i<10;i++>){
        delay_100ms();
    }
}

```

## 1-1.14 break 和 continue 语句

### 定义

break: 用于 do-wile、for、while 等循环语句中，可使程序终止本循环语句，跳出循环语句（永久终止循环）

continue： 用于 do-wile、for、while 等循环语句中，可使停止本次循环，不跳出循环语句，重新开始新的循环（终止本次循环）

### 范例

```C
void main(void)
{
	unsigned char i;

	LED1 = 0;
	LED2 = 0;
	Delay_3s();
	for(i=0;i<5;i++)
	{
		if(i == 2)
		{
			break;//continue
		}
		LED1 = 1;
		LED2 = 1;
		Delay1000ms();
		LED1 = 0;
		LED2 = 0;
		Delay1000ms();
	}

	while(1);
}
//break时，灯闪烁2此
//continue时，灯闪烁4次
```

## 1-1.15 goto 语句

goto 语句又叫无条件转移语句，可以让程序跳转到任意标记的位置

### 格式

```C
goto |lable......|lable:
```

### 范例

```C
#include <STC15F2K60S2.H>

sbit LED1 = P3^1;
sbit LED2 = P3^0;


void Delay1000ms()		//@5.5296MHz   演示1秒的延时函数
{
	unsigned char i, j, k;
	i = 22;
	j = 3;
	k = 227;
	do
	{
		do
		{
			while (--k);
		} while (--j);
	} while (--i);
}


void Delay_3s(void)
{
	unsigned char i;
	for(i=0;i<3;i++)
	{
		Delay1000ms();
	}
}


void main(void)
{
	unsigned char i;

	LED1 = 0;
	LED2 = 0;

	Delay_3s();


lab1:		for(i=0;i<2;i++)
	{
		LED1 = 1;
		LED2 = 1;
		Delay1000ms();
		LED1 = 0;
		LED2 = 0;
		Delay1000ms();
	}
	goto lab1;
	while(1)
	{
		LED1 = 1;
		LED2 = 1;
		Delay1000ms();
		lab2:
		LED1 = 0;
		LED2 = 0;

	}
}
```

## 1-1.16 逻辑运算符

|     符号     |  运算  |
| :----------: | :----: |
|      &&      | 与运算 |
| &#124;&#124; | 或运算 |
|      !       | 非运算 |

### 与运算范例

```C
void main(void)
{
	unsigned char i;
	//与运算   if   while
	unsigned a,b,c;
	a = 1;
	b = 2;
	c = 3;

	LED1 = 0;
	LED2 = 0;

	if((b>a)&&(b<c))
	{
		LED1 = 1;
        LED2 = 1;
	}
	while(1)
}
```

### 或运算范例

```C
void main(void)
{
	unsigned char i;
	//与运算   if   while
	unsigned a,b,c;
	a = 6;
	b = 2;
	c = 3;

	LED1 = 0;
	LED2 = 1;

	if((b>a)||(b<c))
	{
		LED1 = 1;
        LED2 = 1;
	}
	while(1)
}
```

## 1-1.17 赋值运算符

|             |              |                |
| :---------: | :----------: | :------------- |
|     a=b     |     a=b      | 基本赋值运算符 |
|    a+=b     |    a=a+b     | 加赋值         |
|    a-=b     |    a=a-b     | 减赋值         |
|    a\*=b    |    a=a\*b    | 乘赋值         |
|    a/=b     |    a=a/b     | 除赋值         |
|    a%=b     |    a=a%b     | 求余赋值       |
|    a<<=b    |    a=a<<b    | 左移赋值       |
|    a>>=b    |    a=a>>b    | 右移赋值       |
|    a&=b     |    a=a&b     | 按位与赋值     |
| a &#124; =b | a=a &#124; b | 按位或赋值     |
|   a\*^=b    |   a=a\*^b    | 按位异或赋值   |

### 按位运算范例

```C
unsigned char a;
a = 10;
a <<= 1;
//a = a<<1;
//a = 0b 0000 1010 = 0x10
//a<<1=0b 0001 0100 = 0x14
```

```C
unsigned char a;
a = 10;
a >>= 1;
//a = a>>1;
//a = 0b 0000 1010 = 0x10
//a>>1=0b 0000 0101 = 0x05
```

```C
unsigned char a;
a = 10;
a &= 3;
//a = a&3;
//a = 0b 0000 1010 = 0x10
//3 = 0b 0000 0011
//a&3=0b 0000 0010 = 0x02
```

## 1-1.18 函数定义及调用

### 概念

函数是一段可以重复使用的代码，用来独立完成某个功能。它可以接收用户传递的数据，也可以不接收。接收用户数据的函数在定义时要指明参数，不接收用户数据的不需要指明。

### 格式

```C
返回值类型 函数名称（参数声明）
{
    函数体
}
//返回值类型：void/char/unsigned char/int/float/char/void，不可省略
//函数名：他是标识符的一种，程序员可以定义，但不能重复
//参数声明：参数可以有多个，无参数时可以省略
//
```

## 1-1.19 include-sfr-sbit 关键字

### \#include

\#include 包含一个源代码文件的头文件

\#include <文件名>//如果需要包含标准库头文件或者实现版本所提供的头文件

```C
#inlude <math.h>
```

\#include "文件名"//如果需要包含针对程序所开发的源文件

```C
#inlude "myfile.h"
```

<>和""的主要区别在于头文件的搜索路径不同。
<>编译器会到系统路径下查找头文件
""编译器首先在当前目录下查找头文件，如果没有再到系统路径下查找

```c
\keil\C51\INC\STC
//默认头文件存放路径
```

### sfr

特殊功能寄存器（SFR）是用来对片内各功能模块进行管理、控制、监视的控制寄存器和状态寄存器，是一个特殊功能的 RAM 区。STC15 系列单片机内额特殊功能寄存器（SFR）必须用直接寻址指令访问。

单片机如 8051 有 21 个 SFR，地址为 80H~0FFH 的 128 个字节中，可以直接用寻址方式来操作 SFR。(类似于 sbit)。为了能直接访问这些 SFR，keil 提供了一种定义方法。这种方法只适用于 8051 系列单片机进行 C 编程。

#### sfr 语法

```C
sfr sfr_name = int address
```

### sbit

用于特殊功能寄存器中可位寻址的位地址

## 1-1.20 C 语言条件编译命令

根据不同条件编译不同代码产生不同的目标文件的机制。

常见的条件编译语句

```C
#if...#elif...#else...#endif

#ifndef...#else...#endif

#ifdef...#else...#endif
```

### \#if 语法

```C
//1
#if 整型常量表达式1
    程序段1
#elif 整型常量表达式2
    程序段2
#elif 整型常量表达式3
    程序段3
#else
    程序段4
#endif
//如常“表达式1”的值为真（非0），就对“程序段1”进行编译，否则就计算“表达式2”，结果为真的话就对“程序段2”进行编译，为假的话就继续往下匹配，直到遇到值为真的表达式，或者遇到 #else
//#endif与#if配套使用，不能省略

//2
#if 整型常量表达式1
    程序段1
#endif

//3
#if 整型常量表达式1
    程序段1
#elif 整型常量表达式2
    程序段2
#endif

//4
#if 整型常量表达式1
    程序段1
#else
    程序段2
#endif
```

### \#if 范例

```C
#include <stdio.h>
int main(){
    #if _WIN32
        printf("This is Windows!\n");
    #else
        printf("Unknown platform!\n");
    #endif

    #if __linux__
        printf("This is Linux!\n");
    #endif
    return 0;
}
//判断该代码运行在哪个系统下
```

### \#ifdef 语法

```C
//1
#ifdef  表达式1
    程序段1
#else
    程序段2
#endif
//如果表达式1为当前已被定义过的宏，则对“程序段1”进行编译，否则对“程序段2”进行编译
//#endif与#ifdef配套使用，不能省略

//2
#ifdef  表达式1
    程序段
#endif
//如果表达式1为当前已被定义过的宏，则对“程序段1”进行编译
//#endif与#ifdef配套使用，不能省略
```

### \#ifndef 语法

```C
#ifndef 表达式1
    程序段1
#else
    程序段2
#endif
//如果表达式1不是当前定义郭的宏，则对“程序段1”进行编译，否则对“程序段2”进行编译，这与 #ifdef 的功能正好相反
//#endif与#ifndef配套使用，不能省略
```

### \#ifdef 和 \#ifndef 范例

```C
#include <stdio.h>
#include <stdlib.h>
int main(){
    #ifdef _DEBUG
        printf("正在使用 Debug 模式编译程序...\n");
    #else
        printf("正在使用 Release 模式编译程序...\n");
    #endif
    system("pause");
    return 0;
}
//VS/VC 有两种编译模式，Debug 和 Release。在学习过程中，我们通常使用 Debug 模式，这样便于程序的调试；而最终发布的程序，要使用 Release 模式，这样编译器会进行很多优化，提高程序运行效率，删除冗余信息。

//上面的代码是为了能够清楚地看到当前程序的编译模式
```

<font color=Red>\#if 后面跟的是“整型常量表达式”

#ifdef 和 #ifndef 后面跟的只能是一个宏名，不能是其他的</font>

## 1-1.21 一维数组

### 定义

指存储一个固定大小，类型相同的顺序集合

数组是用来存储一组类型相同的变量

### 语法结构

```C
dataType arrayName[length];
//dataType：数据类型
//arrayName：数组名称
//length：数组长度，必须是一个整数型的常量，可以省略
//例    char 1602Dat[16];
```

### 数组的初始化（赋值）

```C
//方法1
unsigned char dig[8]={1,2,3,4,5,6,7,8};
//dig[0] == 1;
//dig[1] == 2;
//dig[2] == 3;
//dig[3] == 4;
//dig[4] == 5;
//dig[5] == 6;
//dig[6] == 7;
//dig[7] == 8;
```

```C
//方法2
unsigned char dig[]={0,1,2,3,4,5,6,7};
```

### 单片机里对数组的修饰

```C
unsigned char code dig[8]={0,1,2,3,4,5,6,7};
//在keil C51里加 code 修饰表示变量存储到rom flash内，无code变量存储在ram里。而ram空间有限，数组容易超大，故较大数组建议加code修饰从而存储在rom里
//在keil MDK里加 const 修饰表示变量存储到rom
```

## 1-1.22 多维数组

### 语法结构

```C
dataType arrayName[length1][length2][length3];
//dataType：数据类型
//arrayName：数组名称
//length1：第一维下标的长度
//length2：第二维下标的长度
//length3：第三维下标的长度
//例 unsigned char Data1602[2][16];
```

```C
unsigned char Data1602[2][16];
/*
{
    {Data1602[0][0],Data1602[0][1],Data1602[0][2],Data1602[0][3],Data1602[0][4],Data1602[0][5],Data1602[0][6],Data1602[0][7],
    Data1602[0][8],Data1602[0][9],Data1602[0][10],Data1602[0][11],Data1602[0][12],Data1602[0][13],Data1602[0][14],Data1602[0][15]
    },
    {Data1602[1][0],Data1602[1][1],Data1602[1][2],Data1602[1][3],Data1602[1][4],Data1602[1][5],Data1602[1][6],Data1602[1][7],
    Data1602[1][8],Data1602[1][9],Data1602[1][10],Data1602[1][11],Data1602[1][12],Data1602[1][13],Data1602[1][14],Data1602[1][15]
    }
}
*/
```
